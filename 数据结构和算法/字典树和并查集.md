### å­—å…¸æ ‘(Trieæ ‘)

å­—å…¸æ ‘(Trieæ ‘)æ˜¯ä¸€ç§ç”±â€œç»“ç‚¹â€å’Œâ€œå¸¦æœ‰å­—ç¬¦çš„è¾¹â€æ„æˆçš„æ ‘å½¢ç»“æ„ã€‚
å…¸å‹åº”ç”¨æ˜¯ç”¨äºç»Ÿè®¡å’Œæ’åºå¤§é‡çš„å­—ç¬¦ä¸²(ä½†ä¸ä»…é™äºå­—ç¬¦ä¸²)ï¼Œç»å¸¸è¢«æœç´¢å¼•æ“ç³»ç»Ÿç”¨äºæ–‡æœ¬è¯é¢‘ç»Ÿè®¡ã€‚
å®ƒçš„ä¼˜ç‚¹æ˜¯:æœ€å¤§é™åº¦åœ°å‡å°‘æ— è°“çš„å­—ç¬¦ä¸²æ¯”è¾ƒï¼ŒæŸ¥è¯¢æ•ˆç‡æ¯”å“ˆå¸Œè¡¨é«˜ã€‚

#### åŸºæœ¬ç»“æ„ï¼š

1.ç¬¬ä¸€ç§ï¼šèŠ‚ç‚¹å­˜å‚¨å®Œæ•´å•è¯ï¼Œå ç”¨ç©ºé—´å¤§ã€‚

2.ç¬¬äºŒç§ï¼šå­èŠ‚ç‚¹å­˜å‚¨ç”¨äºå­˜å‚¨å•è¯çš„é¢å¤–ä¿¡æ¯ï¼Œå¦‚é¢‘æ¬¡ï¼Œä»æ ¹èŠ‚ç‚¹åˆ°æŸä¸€èŠ‚ç‚¹ï¼Œè·¯å¾„ä¸Šç»è¿‡çš„å­—ç¬¦è¿æ¥èµ·æ¥ä¸ºè¯¥èŠ‚ç‚¹å¯¹åº”çš„å•è¯ã€‚

![image-20240229103107538](.\ç®—æ³•ç¬”è®°.assets\image-20240229103107538.png)

#### å†…éƒ¨å®ç°

1.å­—ç¬¦é›†æ•°ç»„æ³•(ç®€å•)
æ¯ä¸ªç»“ç‚¹ä¿å­˜ä¸€ä¸ªé•¿åº¦å›ºå®šä¸ºå­—ç¬¦é›†å¤§å°(ä¾‹å¦‚26)çš„æ•°ç»„ï¼Œä»¥å­—ç¬¦ä¸ºä¸‹æ ‡ï¼Œä¿å­˜æŒ‡å‘çš„ç»“ç‚¹
ç©ºé—´å¤æ‚åº¦ä¸º O(ç»“ç‚¹æ•° * å­—ç¬¦é›†å¤§å°)ï¼ŒæŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦ä¸º O(å•è¯é•¿åº¦)
é€‚ç”¨äºè¾ƒå°å­—ç¬¦é›†ï¼Œæˆ–è€…å•è¯çŸ­ã€åˆ†å¸ƒç¨ å¯†çš„å­—å…¸ã€‚ä¸ç„¶æµªè´¹å¾ˆå¤šç©ºé—´
2.å­—ç¬¦é›†æ˜ å°„æ³•(ä¼˜åŒ–)
æŠŠæ¯ä¸ªç»“ç‚¹ä¸Šçš„å­—ç¬¦é›†æ•°ç»„æ”¹ä¸ºä¸€ä¸ªæ˜ å°„ (è¯é¢‘ç»Ÿè®¡hash map
æ’åº: orderedmap)
ç©ºé—´å¤æ‚åº¦ä¸º 0(æ–‡æœ¬å­—ç¬¦æ€»æ•°))
æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦ä¸º O(å•è¯é•¿åº¦))ï¼Œä½†å¸¸æ•°ç¨å¤§ä¸€äº›é€‚ç”¨æ€§æ›´å¹¿

#### æ ¸å¿ƒæ€æƒ³
Trie æ ‘çš„æ ¸å¿ƒæ€æƒ³æ˜¯ç©ºé—´æ¢æ—¶é—´
æ— è®ºæ˜¯ä¿å­˜æ ‘çš„ç»“æ„ã€å­—ç¬¦é›†æ•°ç»„è¿˜æ˜¯å­—ç¬¦é›†æ˜ å°„ï¼Œéƒ½éœ€è¦é¢å¤–çš„ç©ºé—´
åˆ©ç”¨å­—ç¬¦ä¸²çš„å…¬å…±å‰ç¼€æ¥é™ä½æŸ¥è¯¢æ—¶é—´çš„å¼€é”€ä»¥è¾¾åˆ°æé«˜æ•ˆç‡çš„ç›®çš„
åˆ†ç»„æ€æƒ³ä¸€ä¸€å‰ç¼€ç›¸åŒçš„å­—ç¬¦ä¸²åœ¨åŒä¸€å­æ ‘ä¸­

#### ä»£ç 

```c++
class Trie {
public:
    Trie() {
        root = new Node();
    }
    
    void insert(string word) {
        /*
        Node *cur = root;
        for (char& c : word) {
            if (cur->child.find(c) == cur->child.end()) {
                // æ–°å»ºä¸€æ¡è¾¹
                cur->child.insert({c,new Node()});
            }
            cur = cur->child[c];
        }
        cur->count++;
        */
        solve(word,true,false);
    }
    
    bool search(string word) {
        /*
        Node *cur = root;
        for (char& c : word) {
            if (cur->child.find(c) == cur->child.end()) {
                // æ²¡æœ‰è¿™æ¡è¾¹
                return false;
            }
            cur = cur->child[c];
        }
        return cur->count > 0;
        */
        return solve(word,false,false);
    }
    
    bool startsWith(string prefix) {
        /*
        Node *cur = root;
        for (char& c : prefix) {
            if (cur->child.find(c) == cur->child.end()) {
                // æ²¡æœ‰è¿™æ¡è¾¹
                return false;
            }
            cur = cur->child[c];
        }
        return true;
        */
        return solve(prefix,false,true);
    }
    // æ˜¯ä¸‰ä¸ªå‡½æ•°ç”¨å¾ˆå¤šå¯ä»¥å¤ç”¨çš„åœ°æ–¹
    bool solve(string& word, bool insertIfNoExist, bool searchPrefix) {
        Node *cur = root;
        for (char& c : word) {
            if (cur->child.find(c) == cur->child.end()) {
                // æ˜¯æ’å…¥
                if (insertIfNoExist) {
                    cur->child.insert({c,new Node()});
                } else {
                    return false;
                }
                
            }
            cur = cur->child[c];
        }
        if (insertIfNoExist) cur->count++;
        if (searchPrefix) return true;
        else return cur->count > 0;
    }
private:
    class Node {
        public:
            unordered_map<char,Node *> child;
            int count;
            Node() {
                count = 0;
            }
    };
    Node *root;
};
```

https://leetcode-cn.com/problems/implement-trie-prefix-tree/

https://leetcode-cn.com/problems/word-search-ii/

### å¹¶æŸ¥é›†(Disjoint Set)

#### åŸºæœ¬ç”¨é€”

1.å¤„ç†ä¸ç›¸äº¤é›†åˆçš„åˆå¹¶å’ŒæŸ¥è¯¢é—®é¢˜

2.å¤„ç†åˆ†ç»„é—®é¢˜

3.ç»´æŠ¤æ— åºäºŒå…ƒå…³ç³»

#### åŸºæœ¬æ“ä½œ

MakeSet(s):
å»ºç«‹ä¸€ä¸ªæ–°çš„å¹¶æŸ¥é›†ï¼Œå…¶ä¸­åŒ…å« Sä¸ªé›†åˆï¼Œæ¯ä¸ªé›†åˆé‡Œåªæœ‰ä¸€ä¸ªå…ƒç´ ã€‚

![image-20240229110003646](E:\dbèµ„æ–™\Note\æ•°æ®ç»“æ„å’Œç®—æ³•\å­—å…¸æ ‘å’Œå¹¶æŸ¥é›†.assets\image-20240229110003646.png)

UnionSet(x,y):
æŠŠå…ƒç´ Xå’Œå…ƒç´ yæ‰€åœ¨çš„é›†åˆåˆå¹¶ã€‚
è¦æ±‚Xå’ŒVæ‰€åœ¨çš„é›†åˆä¸ç›¸äº¤ï¼Œå¦‚æœç›¸äº¤åˆ™æ— éœ€åˆå¹¶ã€‚

![image-20240229110128028](E:\dbèµ„æ–™\Note\æ•°æ®ç»“æ„å’Œç®—æ³•\å­—å…¸æ ‘å’Œå¹¶æŸ¥é›†.assets\image-20240229110128028.png)

Find(x):
æ‰¾åˆ°å…ƒç´ Xæ‰€åœ¨çš„é›†åˆçš„ä»£è¡¨ã€‚
è¯¥æ“ä½œä¹Ÿå¯ä»¥ç”¨äºåˆ¤æ–­ä¸¤ä¸ªå…ƒç´ æ˜¯å¦ä½äºåŒä¸€ä¸ªé›†åˆï¼Œåªè¦å°†å®ƒä»¬å„è‡ªçš„ä»£è¡¨æ¯”è¾ƒä¸€ä¸‹å°±å¯ä»¥äº†ã€‚

![image-20240229110019628](.\ç®—æ³•ç¬”è®°.assets\image-20240229110019628.png)

**è·¯å¾„å‹ç¼©**

å¹¶æŸ¥é›†æœ¬è´¨ä¸Šåªå…³å¿ƒæ¯ä¸ªç»“ç‚¹æ‰€åœ¨çš„é›†åˆï¼Œä¸å…³å¿ƒè¯¥é›†åˆå¯¹åº”çš„æ ‘å½¢ç»“æ„å…·ä½“æ˜¯æ€æ ·çš„ã€‚
è€Œä¸€ä¸ªç»“ç‚¹æ‰€åœ¨çš„é›†åˆç”±æ ¹ç»“ç‚¹ç¡®å®šï¼Œå› æ­¤åœ¨ Find(x)çš„åŒæ—¶æŠŠXå’Œçš„æ‰€æœ‰ç¥–å…ˆç›´æ¥è¿åˆ°æ ¹ç»“ç‚¹ä¸Šï¼Œä¸‹ä¸€æ¬¡å°±å¯ä»¥ä¸€æ­¥èµ°åˆ°æ ¹äº†ï¼Œå‡å°‘ä¸‹æ¬¡æŸ¥è¯¢çš„æ—¶é—´ã€‚

#### å†…éƒ¨å®ç°

æ¯ä¸ªé›†åˆæ˜¯ä¸€ä¸ªæ ‘å½¢ç»“æ„ã€‚
æ¯ä¸ªç»“ç‚¹åªéœ€è¦ä¿å­˜ä¸€ä¸ªå€¼:å®ƒçš„çˆ¶ç»“ç‚¹ã€‚
æœ€ç®€å•çš„å®ç°æ˜¯åªç”¨ä¸€ä¸ªint æ•°ç»„faï¼Œfa[i]è¡¨ç¤ºç¼–å·ä¸ºiçš„ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ã€‚
æ ¹ç»“ç‚¹çš„fa ç­‰äºå®ƒè‡ªå·±

#### ä»£ç 

```c++
class DisjointSet {
public:
	DisjointSet(int n) {
		fa = vector<int>(n, 0);
		for (int i = 0; i < n; i++) fa[i] = i;
	}
	int find(int x) {
		if (x == fa[x]) return x;
        // è¿™é‡Œå¯åˆ†ä¸ºä¸¤æ­¥æ¥å†™
        // 1.fa[x] = find(fa[x]),è·¯å¾„å‹ç¼©ï¼Œæ›´æ”¹xçš„çˆ¶èŠ‚ç‚¹ä¸ºæ ¹ã€‚
        // 2.è¿”å›xçš„çˆ¶èŠ‚ç‚¹ï¼Œfa[x].
		return fa[x] = find(fa[x]);
	}
	void unionSet(int x, int y) {
		x = find(x), y = find(y);
        // ä¸¤ä¸ªé›†åˆçš„æ ¹èŠ‚ç‚¹ä¸åŒï¼Œåˆ™ä¸åœ¨ä¸€ä¸ªé›†åˆã€‚éœ€åˆå¹¶
		if (x != y) fa[x] = y;
	}
private:
vector<int> fa;
};

```

ç›¸å…³é¢˜ç›®ï¼š

https://leetcode-cn.com/problems/number-of-provinces/

https://leetcode-cn.com/problems/surrounded-regions/

[145. è¶…å¸‚ - AcWingé¢˜åº“](https://www.acwing.com/problem/content/147/)

https://leetcode-cn.com/problems/number-of-islands/

### å­—ç¬¦ä¸²

#### atoiå®ç°

[8. å­—ç¬¦ä¸²è½¬æ¢æ•´æ•° (atoi) - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/string-to-integer-atoi/)

```c++
int myAtoi(string s) {
        // 1.è·³è¿‡ç©ºæ ¼
        int index = 0;
        // è®¿é—®å…ƒç´ å‰æ³¨æ„è¶Šç•ŒèŒƒå›´
        while (index < s.size() && s[index] == ' ') index++;
        // 2.åˆ¤æ–­ç¬¦å·ï¼Œåªç”¨ä¸€æ¬¡å°±è¡Œ
        int sign = 1;
        if (index < s.size() && (s[index] == '-' || s[index] == '+')) {
            if (s[index] == '-') sign = -1;
            else sign = 1;
            index++;
        }
        int val = 0;
        int min = -2147483648, max = 2147483647;
        
        // 3.æ˜¯æ•°å­—
        while (index < s.size() && (s[index] >= '0' && s[index] <= '9')) {
            // æ•´æ•°è¶Šç•Œå¤„ç†
            // æº¢å‡ºï¼šval * 10 + (s[index] - '0') > max, å‰é¢å¯èƒ½æº¢å‡ºï¼Œå› æ­¤ç§»é¡¹å¤„ç†
            if (val > (max - (s[index] - '0')) / 10) {
                // ç»å¯¹å€¼ > 2147483647, å¦‚æœæ˜¯è´Ÿæ•°ï¼Œè‡³å°‘ä¹Ÿæ˜¯ -2147483648 äº†ï¼Œä¹Ÿä¸ç”¨æ¥ç€ç®—ä¸‹å»äº†ã€‚
                return sign == -1 ? min : max;
            }
            val = val * 10 + (s[index] - '0');
            index++;
        }
        return val * sign;
    }
```

#### Robin-Karpç®—æ³•

Robin-Karp æ˜¯ä¸€ç§åŸºäº Hash çš„é«˜æ•ˆçš„å­—ç¬¦ä¸²æœç´¢ç®—æ³•

é—®é¢˜:
ç»™å®šé•¿åº¦ä¸º nçš„å­—ç¬¦ä¸²s(æ–‡æœ¬ä¸²)ï¼Œé•¿åº¦ä¸º mçš„å­—ç¬¦ä¸²t(æ¨¡å¼ä¸²)
æ±‚tæ˜¯å¦åœ¨ s ä¸­å‡ºç°è¿‡ (t æ˜¯å¦ä¸º sçš„å­ä¸²)

æœ´ç´ :O(nm),éå†sï¼Œæˆªå–å­ä¸²ä¸tå¯¹æ¯”
Rabin-Karpç®—æ³•: 0(n +m)

æ€è·¯:
è®¡ç®—sçš„æ¯ä¸ªé•¿åº¦ä¸ºmçš„å­ä¸²çš„ Hash å€¼ (ä¸€ä¸ªå®½åº¦ä¸º mçš„æ»‘åŠ¨çª—æ»‘è¿‡s)ï¼Œæ£€æŸ¥æ˜¯å¦ä¸tçš„ Hash å€¼ç›¸ç­‰

##### æ ¸å¿ƒæ€æƒ³

é€‰ç”¨çš„Hashå‡½æ•°ï¼š

å°†å­—ç¬¦ä¸²çœ‹ä½œæ˜¯ä¸€ä¸ªbè¿›åˆ¶æ•°ï¼Œè®¡ç®—å­—ç¬¦ä¸²ï¼ˆåœ¨åè¿›åˆ¶ä¸‹ï¼‰å¯¹på–æ¨¡çš„å€¼ã€‚

egï¼š

å– b = 131ï¼Œp = 2^64 - 1; 

å­—ç¬¦ä¸²foobarçš„hashå€¼ä¸º(a = 1, b = 2, f = 6, o = 15, r = 18)

(f*131^5 + o * 131^4 + o * 131^3 + b * 131^2 + a * 131^1 + r * 131^0 ) mod p = (6* 131^5 + 15 * 131^4 + 15 * 131^3 + 2 * 131^2 + 1 * 131 + 18) mod 2^64 - 1 

é€‰å–çš„bå’Œpçš„å€¼å†³å®šäº† Hash å‡½æ•°çš„è´¨é‡ã€‚
æ ¹æ®ç»éªŒï¼Œb = 131,13331 ç­‰ï¼Œp ä¸ºå¤§è´¨æ•°, p = 1e9 + 7ç­‰ï¼Œå†²çªæ¦‚ç‡æå°
**Hash å€¼ç›¸ç­‰æ—¶å¯ä»¥å†æ¯”å¯¹ä¸€ä¸‹ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œé¿å…Hash ç¢°æ’é—®é¢˜**

**è¿™é‡Œæ³¨æ„bè¿›åˆ¶æ•°ï¼Œaè¦ä»1å¼€å§‹ï¼Œè€Œä¸æ˜¯0. æ¯”å¦‚**

ä»0å¼€å§‹ï¼šaab = 001ï¼Œab = 01ï¼Œä¸¤è€… mod p ç›¸åŒï¼Œä½†å­—ç¬¦ä¸²ä¸ç›¸åŒã€‚

è€Œä»1å¼€å§‹ï¼Œaab = 112ï¼Œab = 12ï¼Œä¸¤è€… mod p ä¸åŒ



å¦‚ä½•å¿«é€Ÿè®¡ç®—ä¸€ä¸ªå­ä¸²çš„hashå€¼ï¼Ÿ

s = â€œfoobarâ€ï¼Œ å…ˆè®¡ç®—6ä¸ªå‰ç¼€å­ä¸²çš„hashå€¼ï¼Œç”¨O(n) ç©ºé—´ä¿å­˜ã€‚H[i] è¡¨ç¤ºå‰iä¸ªå­—ç¬¦ç»„æˆçš„å­ä¸²çš„hashå€¼ï¼Œiä»1å¼€å§‹ã€‚

ğ»[ğ‘–] = Hash (ğ‘  [0 â€¦ ğ‘– âˆ’ 1] ) = (ğ» [ğ‘– âˆ’ 1] âˆ— ğ‘ + ğ‘  [ğ‘– âˆ’ 1] ) mod p

æ¨å¯¼ï¼š

H[1] = f * b^0 % p = f % p

H[2] = (f * b^1 + o ) % p = ( f*b % p + o % p ) % p ,

è€Œ f*b % p = ( f %p * b %p ) % p = ( H[1] * b % p) % p = ( H[1] %p * b %p % p ) % p = (H[1] % p * b %p ) % p = ( H[1] * b )% p  

æ‰€ä»¥ H[2] = (f * b^1 + o ) % p = ( **f*b % p** + o % p ) % p  = ( **( H[1] * b )% p**  +  o % p) % p =  (H[1] * b + o) % p

å–æ¨¡è¿ç®—è§„å¾‹ï¼š

(*a*+*b*)%*n *= ((*a*%*n*)+(*b*%*n*))%*n 

(*a*âˆ’*b*)%*n* = ((*a*%*n*)âˆ’(*b*%*n*)+*n*)%*n*ã€‚

(aÃ—b)%n = ((*a*%*n*)Ã—(*b*%*n*))%*nã€‚



å­—ç¬¦ä¸²foobarï¼Œè®¡ç®—å­ä¸²oba çš„hashå€¼ï¼š

ç›¸å½“äºb è¿›åˆ¶ä¸‹ä¸¤ä¸ªæ•°åšå‡æ³• ( H[5] - H[2] * b^3)

  fooba

 -fo000 = oba

æ¨å¯¼ï¼š

H(oba) = H(fooba - fo000) = 

(fooba - fo000) % p  = ((fooba % p - fo000 % p ) + p) % p 

è€Œ fooba % p  = H[5],  

fo000 % p =  (f x b^4 + o x b^3 + 0 + 0 + 0) % p=  (f x b^4 + o x b^3) % p = ((f * b+ o) * b^3 ) % p = ((f * b+ o) % p * b^3 % p) % p = (H[2] * b^3 %p) %p = (H[2] %p * b^3%p %p ) % p = 

(H[2] % p * b^3 %p) %p = (H[2] * b^3) % p

ç»“è®ºï¼š

s[l,r]è¡¨ç¤ºä»lä½ç½®å¼€å§‹åˆ°ræˆªæ­¢çš„å­ä¸²ï¼Œå…¶hashå€¼ä¸º

**så­—ç¬¦ä¸²ä¸‹æ ‡ä»0å¼€å§‹çš„æƒ…å†µï¼šHash (ğ‘  [ğ‘™ â€¦ ğ‘Ÿ] ) = ( ğ» [ğ‘Ÿ + 1] âˆ’ ğ» [ğ‘™] âˆ— ğ‘^ ğ‘Ÿâˆ’ğ‘™+1 ) mod ğ‘ ,O(1)**

**så­—ç¬¦ä¸²ä¸‹æ ‡ä»1å¼€å§‹çš„æƒ…å†µï¼šHash (ğ‘  [ğ‘™ â€¦ ğ‘Ÿ] ) = ( ğ» [ğ‘Ÿ ] âˆ’ ğ» [ğ‘™ - 1] âˆ— ğ‘^ ğ‘Ÿâˆ’ğ‘™+1 ) mod ğ‘ ,O(1)**

##### ä»£ç å®ç°

é¢˜ç›®ï¼š

[28. æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ä¸‹æ ‡ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) return 0;
        if (haystack.size() < needle.size()) return -1;
        haystack = ' ' + haystack;
        needle = ' ' + needle;
        // H[i] ä¸ºå‰iä¸ªå­—ç¬¦çš„hashå€¼
        H.push_back(0);
        for (int i = 1; i < haystack.size(); i++) {
            H.push_back((H[i-1] * b + haystack[i] - 'a' + 1) % p);
        }
        long long needleHash = 0;
        p131.push_back(1);
        for (int i = 1; i < needle.size(); i++) {
            needleHash = (needleHash * b + needle[i] - 'a' + 1) % p;
            p131.push_back(p131[i-1] * b % p); // è®¡ç®—131çš„næ¬¡æ–¹
        }
        int n = needle.size() - 1;
        int r = n;
        // æ»‘åŠ¨çª—ç»“å°¾
        while (r < haystack.size()) {
            if (calcHash(r - n + 1, r) == needleHash && haystack.substr(r - n + 1, n) == needle.substr(1, n)) return r - n;
            r++;
        }
        return -1;
    }

private:
    // [l,r]
    // åšå‡æ³•å¯èƒ½æ˜¯è´Ÿæ•°ï¼Œå–æ¨¡è¿˜æ˜¯è´Ÿï¼Œæ‰€ä»¥å†åŠ ä¸Špåœ¨å–æ¨¡
    long long calcHash(int l, int r) {
        return ((H[r] - H[l - 1] * p131[r - l + 1]) % p + p ) % p; 
    }
    int b = 131, p = 1e9 + 7;
    vector<long long> H; // æ–‡æœ¬ä¸²å‰ç¼€hashå€¼
    vector<long long> p131; // pow 131
};
```

ä¹Ÿå¯ä»¥å°†hashå€¼è¡¨ç¤ºä¸ºunsigned intï¼Œå–pä¸º2^32 - 1ï¼Œè¿™æ ·ä¸ç”¨æ˜¾ç¤ºå–æ¨¡ï¼Œå› ä¸ºæ•°ä¸Šæº¢å‡ºåå°±ç›¸å½“äºå¯¹2^32 - 1å–æ¨¡ï¼Œå› ä¸ºunsigned intçš„max + 1 = 0ï¼Œè¡¥ç è¡¨ç¤ºå…¶å®æ˜¯ä¸€ä¸ªç¯ã€‚

```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        if (needle.empty()) return 0;
        if (haystack.size() < needle.size()) return -1;
        // 1.æ±‚æ–‡æœ¬ä¸²så‰ç¼€å­ä¸²hash
        vector<unsigned int> H;
        haystack = ' ' + haystack; // ä¸‹æ ‡ä»1å¼€å§‹
        needle = ' ' + needle;
        H.push_back(0); 
        for (int i = 1; i < haystack.size(); i++) {
            H.push_back(H[i-1] * 131 + haystack[i] - 'a' + 1); // è®©å…¶è‡ªåŠ¨æº¢å‡ºï¼Œç›¸å½“äºå¯¹unsigned int maxå–æ¨¡
        }
        // 2.æ±‚æ¨¡å¼ä¸²tçš„hashå€¼
        unsigned int tHash = 0;
        vector<unsigned int> p131; // p131[i] = 131^i
        p131.push_back(1);
        for (int i = 1; i < needle.size(); i++) {
            tHash = tHash * 131 + needle[i] - 'a' + 1;
            p131.push_back(p131[i-1] * 131);
        }
        // 3.æ»‘åŠ¨çª—å£ä¸­å­ä¸²s[l..r]hashå€¼ = H[r] - H[l-1] * 131^n ä¸ æ¨¡å¼ä¸²çš„hashå€¼ç›¸æ¯”ã€‚
        int n = needle.size() - 1;
        for (int r = n; r < haystack.size(); r++) {
            // é¿å…hashå†²çª(æ¦‚ç‡å¾ˆå°)ï¼Œè¿›ä¸€æ­¥å¯¹æ¯”å­ä¸²
            if ((H[r] - H[r - n] * p131[n]) == tHash && 
                haystack.substr(r - n + 1, n) == needle.substr(1,n)) return r - n;
        }
        return -1;
    }
};
```

Rabin-Karpç®—æ³•çš„å¹¿æ³›é€‚ç”¨æ€§
ç”±äº Rabin-Karp ç®—æ³• O(n) é¢„å¤„ç† + O(1)æ±‚å‡ºä»»æ„å­ä¸²å“ˆå¸Œå€¼çš„ç‰¹æ€§ã€‚
é…åˆäºŒåˆ†æŸ¥æ‰¾ã€äºŒåˆ†ç­”æ¡ˆç­‰æŠ€å·§ï¼Œå¯ä»¥ä½œä¸ºå­—ç¬¦ä¸²åŒ¹é…ã€å›æ–‡ç­‰ä¸€ç³»åˆ—é—®é¢˜çš„æ¬¡ä¼˜è§£ (å¯èƒ½æ¯”æœ€ä¼˜è§£å¤šä¸€ä¸ªlog çš„æ—¶é—´å¤æ‚åº¦ã€‚
