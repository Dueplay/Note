bufferpoll

frame满了怎么办：驱逐一个页，驱逐算法，lru，lru-k。可以被驱逐的页都是pin = 0的。在选驱逐页时判断是否是还在pin的，pin-count > 0的页是不能被驱逐的。

unpin和pin，如果没有unpin会怎么样。

flush刷脏页，为啥在有日志(write ahead logging)的情况下，还要定期刷脏页？

​	还维护一个flush链表，定期刷脏，好处是恢复的时候可以减少操作量。只依赖WAL而不定期刷脏页，一旦系统崩溃，恢复时需要从日志重做的操作可能非常多，导致恢复时间较长。定期刷脏页可以减少系统恢复时需要重做的操作数量，从而显著缩短恢复时间。

WAL日志：WAL 机制确保在数据页更新之前，先将这些修改记录（日志）写入磁盘。这样即使数据库崩溃，在恢复时也可以根据日志重做未完成的操作，确保数据一致性。

日志的作用： recover的时候根据日志恢复成crash之前的样子。

死锁了怎么办，如何检测死锁，构建wait-for依赖图，对于一个资源，阻塞的事务等待已经获得该资源锁的事务，判断是否有环，dfs或者拓扑排序判断

2PL协议是一个悲观的并发控制协议，它使用锁来确定是否允许事务动态访问数据库中的对象。 协议不需要提前知道事务将执行的所有查询。

**GROWING阶段**：每个事务都会向 DBMS 的锁管理器请求所需的锁。 锁管理器授予/拒绝这些锁请求。

**SHRINKING阶段**：**事务在释放第一个锁后立即进入收缩阶段**。 在收缩阶段，只允许事务释放锁。 他们不允许购买新的。

对于每种隔离级别有所不同：

2PL 足以保证冲突可串行化。 它生成优先级图是无环的调度。 但它很容易受到级联中止的影响，即当一个事务中止时，现在必须回滚另一个事务，这会导致工作浪费。2PL 仍然可能存在脏读，并且还可能导致死锁。 还有一些潜在的计划是可序列化的，但 2PL 不允许（锁定会限制并发性）。

**级联中止**：在两阶段锁协议（2PL）中，事务可能会读取其他事务尚未提交的数据（这取决于隔离级别），这种读取行为会形成依赖关系。当一个事务中止时，所有依赖于该事务读取未提交数据的事务也必须中止，这会导致工作浪费和系统性能下降。

假设有两个事务T1和T2，T1先执行，T2依赖于T1的数据进行操作：

1. **T1**：开始事务，写入数据A。
2. **T2**：开始事务，读取数据A（此时A尚未提交）。
3. **T1**：由于某种原因中止（回滚）。

在这种情况下，因为T2读取了T1的未提交数据，如果T1中止，T2也必须中止，以确保数据的一致性。



如果一个事务写入的任何值在这个事务提交之前不会被另一个事务读取或覆盖，则调度是严格的。**严格两阶段锁协议（Strict 2PL）**：**事务仅在提交时释放锁。 这种方法的优点是可以防止其他事务读取未提交的数据， 不会导致级联中止**。 DBMS 还可以通过恢复已修改元组的原始值来反转中止事务的更改。 严格的 2PL 会生成更加谨慎/悲观的计划，从而限制并发性。

**可恢复调度**：确保所有读取未提交数据的事务在其依赖事务提交之后再提交，从而防止级联中止，但影响并发性能。

处理 2PL 中的死锁有两种方法：检测和预防

1.死锁检测

为了检测死锁，DBMS 创建一个等待图，其中事务是节点，如果事务 Ti 正在等待事务 Tj 释放锁，则存在从 Ti 到 Tj 的有向边。 系统将定期检查等待图中的环（通常使用后台线程），然后决定如何打破它。

 当 DBMS 检测到死锁时，它将选择一个“受害者”事务来中止以打破循环。 受害者事务将重新启动或中止，具体取决于应用程序调用它的方式。

2.死锁预防

死锁预防不是让事务尝试获取所需的任何锁，然后再处理死锁，而是**在事务发生之前阻止事务导致死锁**。 当一个事务试图获取另一个事务持有的锁时（这可能会导致死锁），DBMS 会杀死其中一个事务。

为了实现这一点，根据时间戳为事务分配优先级（**较旧的事务具有更高的优先级**）。 这些方案保证不会出现死锁，因为等待锁时只允许一种方向。 当事务重新启动时，DBMS 会重用相同的时间戳。 在死锁预防下，有两种方法可以终止事务： 

• wait-die（“Old Waits for Young”）：如果请求事务的优先级高于持有事务，则它会等待。 否则，它将中止。

 • Wound-Wait（“Young Waits for Old”）：如果请求事务的优先级高于持有事务，则持有事务将中止并释放锁。 否则，请求事务将等待。



锁粒度：

数据库锁层次结构：

1. 数据库级（很少见） 
2. 表级（很常见）
3.  页级（常见） 
4. 元组级（很常见）
5.  属性级（很少见）

意向锁允许以共享模式或独占模式锁定更高级别的节点，而无需检查所有后代节点。 如果节点处于意图模式，则显式锁定将在树中的较低级别完成。 

• 意向共享(IS)：表示事务打算在更细粒度（如行级别）上获取共享锁（S锁）

可以在更高级别（如表级别）上与其他IS锁、IX锁共存，但不能与S锁、X锁、SIX锁共存。

• 意向独占(IX)：示事务打算在更细粒度（如行级别）上获取排他锁（X锁）。

以在更高级别（如表级别）上与其他IS锁、IX锁共存，但不能与S锁、X锁、SIX锁共存。

• 共享+意图独占(SIX)：表示事务已经在更高级别（如表级别）上获取了共享锁（S锁），并打算在更细粒度（如行级别）上获取排他锁（X锁）。

可以在更高级别上与其他IS锁、IX锁共存，但不能与S锁、X锁共存。



时间戳排序协议：

基本时间戳排序协议 (BASIC T/O) 允许在不使用锁的情况下读取和写入数据库对象（乐观的）。每个数据库对象 X 都标有在该对象上成功执行读取（表示为 R-TS(X)）或写入（表示为 W-TS(X)）的最后一个事务的时间戳。DBMS 检查每个操作的这些时间戳。 如果事务尝试以违反时间戳顺序的方式访问对象，则事务将中止并重新启动。

读操作：如果TS(Ti) < W-TS(X), 则Ti被终止并使用重新的时间戳启动。如果TS(Ti) >= W-TS(X), 读取有效并且允许Ti读取X。然后DBMS将R-TS(X)更新为R-TS(X)和TS(Ti)中的最大值。它还必须在私有工作区中制作 X 的本地副本，以确保 Ti 的可重复读取。

写操作：如果 TS(Ti) < R-TS(X) 或 TS(Ti) < W-TS(X)，则必须重新启动 Ti。 否则，DBMS允许Ti写入X并更新W-TS(X)。 同样，它需要制作 X 的本地副本以确保 Ti 的可重复读取。

优化：Thomas 写入规则：写入的优化是，如果 TS(Ti) < W-TS(X)，则 DBMS 可以忽**略写入并允许事务继续**，而不是中止并重新启动它。 这称为托马斯写入规则。 请注意，这违反了 Ti 的时间戳顺序，但这没关系，因为没有其他事务会读取 Ti 对对象 X 的写入， 因为读的事务的TS>=W-TS(X)。如果不使用 Thomas Write 规则，基本 T/O 协议会生成一个可冲突序列化的调度。 它不会出现死锁，因为没有事务会等待。 然而，如果短事务持续引起冲突，则长事务可能会出现饥饿。

潜在问题：

 • 将数据复制到事务工作区以及更新时间戳会产生较高的开销。

 • 长时间运行的事务可能会陷入饥饿状态。 事务从较新的事务中读取某些内容的可能性会增加。 

• 在高并发系统上遇到时间戳分配瓶颈。



OCC协议

乐观并发控制（OCC）是另一种乐观并发控制协议，它也使用时间戳来验证事务。 当冲突数量较少时，OCC 效果最佳。 这是当所有事务都是只读的或者当事务访问不相交的数据子集时。 如果数据库很大并且工作负载不偏斜，那么发生冲突的可能性就很低，这使得 OCC 成为一个不错的选择。 **在 OCC 中，DBMS 为每个事务创建一个私有工作区。 事务的所有修改都会应用于此工作区。 读取的任何对象都会复制到工作区，写入的任何对象都会复制到工作区并在其中进行修改。 任何其他事务都无法读取另一个事务在其私有工作区中所做的更改。** 当事务提交时，DBMS 会比较该事务的工作区写入集，以查看它是否与其他事务冲突。 如果不存在冲突，则写入集将安装到“全局”数据库中。

OCC 包含三个阶段：

1. 读取阶段：在此阶段，DBMS 跟踪事务的读/写集并将其写入存储在事务的私有工作区中。  
2. 验证阶段：当事务提交时，DBMS 检查它是否与其他事务冲突。 
3. 写入阶段：如果验证成功，DBMS 将私有工作区更改应用到数据库。 否则，它将中止并重新启动事务。

当事务进入验证阶段时，DBMS 会为其分配时间戳。 为了确保只允许可序列化的调度，DBMS 将 Ti 与其他事务检查 RW 和 WW 冲突，并确保所有冲突都是单向的。

后向验证：在事务提交前检查它与之前已经验证通过的事务是否存在冲突。在后向验证中，事务只需与已经提交的事务进行验证。

假设有两个事务Ti和Tj，且Ti的CTS(提交时间戳) < Tj的CTS（Ti在Tj之前进入验证阶段），那么Ti和Tj的验证条件如下：

1. **Ti的写集合与Tj的读集合是否有交集**：
   - 如果Ti的写集合与Tj的读集合有交集，说明Tj在读阶段读取的数据被Ti修改了，Tj的结果可能无效，因此Tj需要回滚。
2. **Ti的写集合与Tj的写集合是否有交集**：
   - 如果Ti的写集合与Tj的写集合有交集，说明Tj在写入数据时可能会覆盖Ti的写入，导致数据不一致，因此Tj需要回滚。

前向验证：

DBMS 检查提交事务与所有其他正在运行的事务的时间戳顺序。 尚未进入验证阶段的事务被分配时间戳为 ∞。

如果 TS(Ti) < TS(Tj)，则必须满足以下三个条件之一： 	1. Ti 在 Tj 开始执行之前完成所有三个阶段（串行排序）。

2. Ti 在 Tj 开始写入阶段之前完成，并且 Ti 不会写入 Tj 读取的任何对象。 • 写入集(Ti) ∩ 读取集(Tj) = ∅。

3.  Ti 在 Tj 完成其读取阶段之前完成其读取阶段，并且 Ti 不会写入由 Tj 读取或写入的任何对象。 • WriteSet(Ti) ∩ ReadSet(Tj) = ∅，并且WriteSet(Ti) ∩ WriteSet(Tj) = ∅。

   

可串行性非常有用，因为它允许程序员忽略并发问题，但强制执行它可能会导致并行性过低并限制性能。 我们可能希望使用较弱的一致性级别来提高可扩展性。 隔离级别控制事务暴露给其他并发事务的操作的程度。

 异常：

 • 脏读：读取未提交的数据。

 • 不可重复读取：重做读取会导致不同的结果。 

• 幻读：插入或删除会导致相同范围扫描查询的不同结果。 

隔离级别（从最强到最弱）： 

1. 可串行化：无幻读，所有读取均可重复，且无脏读。 
2. 可重复读取：幻读可能会发生。
3. READ-COMMITTED：可能会发生幻读和不可重复读。 
4. READ-UNCOMMITTED：所有异常情况都可能发生。





MVVC

当事务写入对象时，DBMS 会创建该对象的新版本。 当事务读取对象时，它会读取事务启动时存在的最新版本。 MVCC 的基本概念/好处是写入者不会阻止写入者，读取者不会阻止读取者。 这意味着一个事务可以修改对象，而其他事务则读取旧版本。

有四个重要的 MVCC 设计决策： 1. 并发控制协议 2. 版本存储 3. 垃圾收集 4. 索引管理 

并发协议的选择是（两阶段锁定、时间戳排序、乐观并发控制） ）。



日志

缓冲池管理策略

DBMS 需要确保以下保证：

 • 一旦 DBMS 告诉某人它已提交，任何事务的更改都是持久的。

 • 如果事务中止，则任何部分更改都不会持久。

 窃取策略规定 DBMS 是否允许未提交的事务覆盖非易失性存储中对象的最近提交的值（事务是否可以将属于不同事务的未提交的更改写入磁盘？）。 

• STEAL：允许。 

• NO-STEAL：不允许。

 强制策略指示 DBMS 是否要求在允许事务提交（即，将提交消息返回给客户端）之前，事务所做的所有更新都反映在非易失性存储上。 

• FORCE：需要 

• NO-FORCE：不需要 

强制写入可以更轻松地恢复，因为所有更改都会保留，但会导致运行时性能较差。

最容易实施的缓冲池管理策略称为 NO-STEAL + FORCE。 在此策略中，DBMS 永远不必撤消中止事务的更改，因为更改不会写入磁盘。 它也永远不需要重做已提交事务的更改，因为所有更改都保证在提交时写入磁盘。

WAL

通过预写日志记录，DBMS 在对磁盘页面进行更改之前，将对数据库所做的所有更改记录在日志文件（稳定存储上）中。 该日志包含足够的信息来执行必要的撤消和重做操作，以在崩溃后恢复数据库。 DBMS 必须先将与对数据库对象所做的更改相对应的日志文件记录写入磁盘，然后才能将该对象刷新到磁盘。 

每个日志条目都包含回退或重播对单个对象的更改所需的信息： 

• 事务 ID。

• 对象ID。

 • Before Value（用于UNDO）。 

• After Value（用于REDO）。



两阶段协议，为啥这样就能实现RR的隔离级别？

在读取时获取并保持读锁直到事务结束。

在写入时获取写锁，持续到事务结束。

事务A在事务开始时读取某行数据并获取读锁。在事务A提交之前，事务B无法修改这一行数据，因为读锁阻止了写锁的获取，从而确保事务A在整个事务期间读取到一致的数据。

介绍三种这隔离级别，会出现的问题?

RU: 允许事务读取尚未提交的其他事务的修改，脏读。

RC：仅允许事务读取已经提交的其他事务的修改，不可重复读。

RR：确保在事务执行期间，每次读取的数据都是一致的，可能会幻读，其他事务在两次读取之前插入了数据。

ACID

介绍时间戳协议

根据时间戳协议，如果冲突了，该怎么办。undo

SQL执行过程：parse->bind->optimizer->exector



八股：

父类析构函数为啥要设置为virtual，而构造函数不能设置为virtual。

当一个基类指针指向一个派生类对象时，如果**不**将基类的析构函数声明为`virtual`，在删除该基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数。这会导致派生类特有的资源没有被正确释放，可能引发内存泄漏或其他未定义行为。

通过将析构函数声明为`virtual`，在删除基类指针时，程序会调用派生类的析构函数，运行时多态，然后再调用基类的析构函数，从而确保所有资源都能正确释放。

在C++中，对象的构造是从基类到派生类按顺序进行的。当你创建一个派生类对象时，首先会调用基类的构造函数，然后再调用派生类的构造函数。这是因为派生类需要在基类对象被正确初始化之后才能进行初始化。如果构造函数是 `virtual` 的，那么这种顺序会变得不明确，破坏了对象初始化的规则。

虚函数机制依赖于虚函数表（vtable）。每个包含虚函数的类都有一个虚函数表，虚函数表存储了指向该类的虚函数实现的指针。每个对象内部都有一个隐藏的指针，指向它所属类的虚函数表。

当一个对象被创建时，构造过程如下：

1. **分配内存**：为对象分配内存。
2. **初始化vptr**：在调用构造函数之前，编译器会将对象的vptr指向正确的虚函数表。
3. **执行构造函数**：按照从基类到派生类的顺序执行构造函数。



算法题：

每行是一个输入，代表执行计划上的一个节点，根据输入构建出语法树。 根据每行输入的前导零来判断层级关系。

思路：单调栈，栈顶的level >= 当前节点level，栈顶出栈。如果 < , 该节点为栈顶的孩子，然后入栈。

```c
Project
 Join
  Scan
  Filter
   Scan

Project
 Join1
  Join2
   Scan2
   Scan3
  Scan4
```

```c++
#include <iostream>
#include <string>
#include <vector>
#include <stack>

class PlanNode {
public:
    PlanNode(std::string type) : type(type) {}

    std::string type;
    std::vector<PlanNode*> children;

    // 打印树形结构的函数
    void print(int level = 0) {
        // 打印当前节点的类型，带有缩进
        for (int i = 0; i < level; ++i) {
            std::cout << "  "; // 每一级缩进两个空格
        }
        std::cout << type << std::endl;

        // 递归打印子节点
        for (auto child : children) {
            child->print(level + 1);
        }
    }
};
// 从istream std::in中读入一行字符串到string line中
// std::getline(std::in, line);

// 返回一个字符串当中第一个非空格的位置
// line.find_first_not_of(" ");

// 移除前导的count个字符
// line.substr(count); 
// 构造树的函数
PlanNode* buildTree(const std::vector<std::string>& input) {
    std::stack<std::pair<PlanNode*, int>> nodeStack;

    for (const auto& line : input) {
        int level = 0;
        // find_first_not_of
        while (level < line.size() && line[level] == ' ') {
            level++;
        }
        std::string type = line.substr(level);

        PlanNode* newNode = new PlanNode(type);

        while (!nodeStack.empty() && nodeStack.top().second >= level) {
            nodeStack.pop();
        }

        if (!nodeStack.empty()) {
            nodeStack.top().first->children.push_back(newNode);
        }

        nodeStack.push({newNode, level});
    }

    // 返回根节点
    while (nodeStack.size() > 1) {
        nodeStack.pop();
    }
    return nodeStack.top().first;
}

int main() {
    /*
    string line;
    while (getline(cin, line)) {
        input.push_back(line);
    }
    */
    std::vector<std::string> input = {
        "Project",
        " Join1",
        "  Join2",
        "   Scan2",
        "   Scan3",
        "  Scan4"
    };

    PlanNode* root = buildTree(input);
    root->print();

    return 0;
}

```

