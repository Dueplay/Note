## 1.语言

C++ 中 new 和 malloc 有哪些区别？

引用的本质是什么？底层可能是怎样实现的？

> 本质是取别名，指针常量，初始化时绑定，整个生命周期保持不变

一个类在什么时候必须自定义实现拷贝构造函数和赋值构造函数？

> 当这个类中有开辟到堆区的数据时，比如一个指针指向一块开辟到堆上的内存，需要实现深拷贝。浅拷贝会带来两个对象指向同一块内存，在对象析构时会发生双重释放，程序崩溃。

写时拷贝怎么实现？

> 1.**初始状态**：当一个对象被复制时，实际上只复制指向原数据的指针，而不是数据本身。此时，两个对象共享同一块内存。
>
> **2.引用计数**：通常会维护一个引用计数，记录有多少个对象指向同一块内存。这样，当一个对象被复制时，可以增加引用计数。
>
> **3.修改操作**：在执行写操作（例如，修改数据）时，首先检查引用计数。如果引用计数大于1，说明还有其他对象共享同一块内存。这时，创建一份新的副本，并将当前对象指向这个新副本，同时更新引用计数。进行修改操作。
>
> **4.释放内存**：当对象的生命周期结束时，减少引用计数。如果引用计数降为0，则可以安全地释放共享内存

C++11 的特性了解哪些？auto 类型推导是在哪个时期？

> 范围for循环，智能指针，auto关键字，thread。在c++11引入的auto

重载（overload）和重写（override）分别指什么？

> 重载：函数的参数类型不同，个数不同，或类型和个数都不同。name magning机制，c++会将函数修饰为一个形式。eg:funcZ4id
>
> 重写是子类重写父类的虚函数，函数签名需要一致。override关键字可以显示告诉编译器，检查重写函数签名是否一致。

堆和栈有什么区别？

> 1. 存储方式
>
> - **栈**：遵循后进先出（LIFO）原则，内存由系统自动管理。函数调用时，局部变量和参数存储在栈上，函数返回后自动释放。
> - **堆**：用于动态内存分配，大小可变，由程序员手动管理。需要使用 `new` 和 `delete` 进行内存分配和释放。
>
> 2. 内存分配
>
> - **栈**：分配速度快，因为只需移动栈顶指针。栈的大小通常有限制。
> - **堆**：分配速度相对较慢，可能会出现碎片，且堆的大小通常较大。
>
> 3. 生命周期
>
> - **栈**：变量的生命周期由其作用域决定，超出作用域后自动释放。
> - **堆**：变量的生命周期由程序员控制，直到显式释放之前，它们会一直存在。
>
> 4. 使用场景
>
> - **栈**：适合存储小型、短生命周期的局部变量。
> - **堆**：适合存储大型数据结构和需要在多个函数之间共享的对象。

当调用一个函数时，入栈情况是啥样的？

>**保存返回地址**：在调用函数之前，当前执行位置的返回地址（即调用函数后继续执行的位置）被压入栈中。
>
>**创建栈帧**：为该函数调用创建一个新的栈帧，栈帧中通常包含：
>
>- **参数**：传递给函数的参数。
>- **局部变量**：该函数内定义的局部变量。
>- **保存的寄存器状态**：为了在函数返回后能够恢复调用者的状态。
>
>**参数压栈**：如果函数有参数，这些参数会依次压入栈中，通常是从右到左的顺序

怎样用 C++ 写一个类，只能用这个类生成堆上的实例，而不能生成栈上的实例？ 又怎么实现一个类，只能用这个类生成栈上的实例，不能生成堆上的实例？

```c++
class HeapOnly {
private:
    HeapOnly() {} // 私有构造函数

public:
    static HeapOnly* create() {
        return new HeapOnly(); // 只能通过这个静态函数在堆上创建实例
    }

    // 禁用拷贝构造和赋值运算符
    HeapOnly(const HeapOnly&) = delete;
    HeapOnly& operator=(const HeapOnly&) = delete;
};

// 使用示例
int main() {
    HeapOnly* obj = HeapOnly::create(); // 在堆上创建实例
    delete obj; // 记得手动释放内存
    // HeapOnly stackObj; // 错误：无法在栈上创建实例
    return 0;
}

class StackOnly {
private:
    StackOnly() {} // 私有构造函数

public:
    // 友元函数用于创建栈上实例
    friend StackOnly createStackOnly();
};

// 友元函数实现
StackOnly createStackOnly() {
    return StackOnly(); // 直接返回栈上创建的实例
}

// 使用示例
int main() {
    StackOnly stackObj = createStackOnly(); // 在栈上创建实例
    // StackOnly* obj = new StackOnly(); // 错误：无法在堆上创建实例
    return 0;
}

```

